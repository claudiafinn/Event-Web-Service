//Claudia Finn
//Final Project Writeup
//Honor Code Upheld

	My final project combined several Event API's with Google Directions to help a user find local events and their driving and biking distances. This service would ideally make it easy and convenient for people to find interesting events close to home. The two event api's I used were Eventbrite, which hosts user created events such as club meetings, local events, and classes. The second was BandsInTown, which hosts concerts and live music events. There was generally no overlap between the events in the two API's, however it is possible that overlap would exist and I did not address this case because I never encountered it. 
	The program begins with a user interface requesting the users location, the distance they would like to stay within, and the time period they would like to find events in. The location can be any string of letters, numbers, and characters (including crazy ones!) and that string will be passed to Google's Geoencode API. If any location exists that includes a substring of that string, the Geoencode API will find it. If there are multiple locations found, a list of them will be returned which the user will be able to chose from. Once the user selects the correct location (or if they entered a detailed location, like 902 N Cascade Ave Colorado Springs), the GeoEncode API will return the latitude and longitude coordinates to be used as the "origin" for the remainder of the program.
	The distance parameter must be an integer greater than 0, and has an upper limit of 150 miles for BandsInTown and no upper limit for EventBrite. If the user enters a distance greater than 150 it gets decreased to 150. The timeframe must either be "today", "tomorrow", or "this week", exactly, case sensitive. These were options provided by the EventBrite API through a query 'start_date.keyword' which I thought was very convenient. Of course though, I then had to convert these phrases into dates to use in the EventBrite API using the python datetime class.
	Once these three user inputs are validated, the first API call to EventBrite is made which retrieves the requested events sorted by date. This query can be changed to be sorted by other paramters as well, such as 'name', 'distance', or 'best'. Then the first call to BandsInTown occurs which returns it's events that fit the request. The total number of events is combined and the json data from each is dispatched to it's respective getInfo() methods. The first challenge in doing this was sending the same address entered by the user to both API's, because EventBrite could accept almost any combination of street address, zip code, city, such as "colorado springs", "902 N Cascade Ave", "80903", or lat/lon values. BandsInTown, however, could only accept city,state or city,country values. At least, that's what I thought at first! Turns out they can also accept lat/lon coordinates, which is why when the client entered their address I immediately converted it to coordinates.
	These subtle differences in API design continued throughout my project. Once the data was dispatched to their respective programs I had to find a way to retrieve the same information (or very similar information) from every event. The basic things I needed from each event were name, venue, venue location, event time, distance to event driving, distance biking, and a link to information. Retrieving the event name was relatively easy in both cases, but BandsInTown did not have explicit event names, so instead I used the artist or performers name. Venue info was the second challenge I faced. In EventBrite's json data there was a single field called "venue_id" with a corresponding ID number. I therefore had to make a second HTTP request to EventBrite to retreieve the venue info corresponding to that ID. From that json data I was able to obtain the venue name, address and coordinates. In BandsInTown's data I was able to directly obtain the Venue name and coordinates, but it lacked an actual address. Because of this, I changed my geocode method to reverse it's functionality and take as paramters coordinates and return an address or take an address and return coordinates. Then I was able to get the readable address from BandsInTown's venue's coordinates. In both cases Event Time was relatively strait forward, although I have to separate datetime strings. 
	Working with the Google Directions was my third challenge. Originally when I was using string addresses and coordinates as "origin" and "destination" I was getting strange errors where the Google Direction API would not recognize every location. Most of this issue was resolved when I began using strictly coordinates. The next issue was retrieving the human readable directions between locations. If you un-comment the two blocks of text location in the getDirections() method of the GoogleDirections.py file you will get directions printed with every event. I decided this was not the priority of my program as the user would not like directions to every event listed. In the future, I would add functionality so the user could select an event and get the directions to that event specifically. I also experimented with a second directions API called MapBox. I was curious if expecially bike routes would be different depending on the service they were obtained from. Formatting the data to fit this API also proved to be difficult because of MapBox's poor API design. Instead of using the conventional (latitude, longitute) order, they used (longitude, latitude) which is stupid and not intuitive. They also returned their travel time in seconds and their distances in meters which I found cumbersome. Once this API began working I was able to compare the time MapBox estimated it would take to bike and the time Google Maps estimated. Generally, MapBox thought it would take longer although it was generally in the same ball park. You can see this in my output as "comparison time". I did not have enough time to research into the differences in routes and why this time difference may have occured.
	All in all I accomplished what I originally imaged my project would do, plus extra features. There was constantly something else I could change or improve, such as specifying the time range better or working with the directions more specifically. Many of the problems I had to solve involved conflicting API structure and implementation that had to be customized to each API. I would definitely support stricter and more broad API design rules after working on this project. 





